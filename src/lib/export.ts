import fs from 'fs/promises';
import path from 'path';
import AdmZip from 'adm-zip';
import { getProject } from './projects';

export async function createExportZip(projectId: string): Promise<Buffer> {
    const project = await getProject(projectId);
    if (!project) throw new Error('Project not found');

    const projectDir = path.join(process.cwd(), 'projects', projectId);
    const processedDir = path.join(projectDir, 'processed');

    const zip = new AdmZip();

    // Add images and captions
    try {
        const files = await fs.readdir(processedDir);
        for (const file of files) {
            if (file.endsWith('.png') || file.endsWith('.txt')) {
                const content = await fs.readFile(path.join(processedDir, file));
                // Structure: /dataset/img/file.png, /dataset/img/file.txt
                // Or simpler: just flattened
                zip.addFile(`dataset/${file}`, content);
            }
        }
    } catch (e) {
        console.error('Error adding files to zip', e);
    }

    // Add README
    const readmeContent = `
# Dataset: ${project.name}

Generated by LoRA Bento.

## Stats
- Images: ${project.stats.processed}
- Captions: ${project.stats.captions}

## Configuration
- Target Size: ${project.settings.targetSize}
- Trigger Word: ${project.settings.triggerWord || 'None'}
- Caption Model: ${project.settings.captionModel || 'Manual/Imported'}

## Suggested Prompts
${project.settings.triggerWord ? `1. ${project.settings.triggerWord}, ...` : '1. ...'}
  `.trim();

    zip.addFile('README.md', Buffer.from(readmeContent, 'utf-8'));

    // Add metadata.json (Kohya format)
    // Re-generate specific metadata.json for Kohya if needed (image path keys)
    // For now standard is usually text files side-by-side or a metadata.json
    // We'll stick to text files side-by-side as it's most compatible.

    return zip.toBuffer();
}
