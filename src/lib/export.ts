import fs from 'fs/promises';
import path from 'path';
import AdmZip from 'adm-zip';
import { getProject } from './projects';
import { getTrainingSet } from './dataset';

export async function createExportZip(projectId: string): Promise<Buffer> {
    const project = await getProject(projectId);
    if (!project) throw new Error('Project not found');

    const { items, stats } = await getTrainingSet(projectId);
    const zip = new AdmZip();

    // Sort items to ensure deterministic sequential naming
    // Prefer sorting by original fileName if possible, otherwise by ID
    const sortedItems = [...items].sort((a, b) => {
        return a.fileName.localeCompare(b.fileName, undefined, { numeric: true, sensitivity: 'base' });
    });

    const exportMap: Record<string, string> = {};
    let imagesExported = 0;
    let captionsExported = 0;

    // Add images and captions
    for (let i = 0; i < sortedItems.length; i++) {
        const item = sortedItems[i];
        const indexStr = (i + 1).toString().padStart(6, '0');

        try {
            // Check if image exists
            const imgExists = await fs.access(item.imagePath).then(() => true).catch(() => false);
            if (!imgExists) {
                console.warn(`Image not found: ${item.imagePath}`);
                continue;
            }

            // Add Image
            const imgContent = await fs.readFile(item.imagePath);
            const imgExt = path.extname(item.imagePath) || '.png';
            const zipImgPath = `dataset/images/${indexStr}${imgExt}`;

            zip.addFile(zipImgPath, imgContent);
            imagesExported++;

            // Add Caption (if exists)
            const capExists = await fs.access(item.captionPath).then(() => true).catch(() => false);
            if (capExists) {
                const capContent = await fs.readFile(item.captionPath);
                const zipCapPath = `dataset/images/${indexStr}.txt`;
                zip.addFile(zipCapPath, capContent);
                captionsExported++;
            }

            // Map exported name to original filename (for debugging/reference)
            exportMap[`${indexStr}${imgExt}`] = path.basename(item.imagePath);
        } catch (e) {
            console.error(`Error adding item ${item.id} to zip`, e);
        }
    }

    // Add export_map.json
    zip.addFile('export_map.json', Buffer.from(JSON.stringify({
        projectId: project.id,
        projectName: project.name,
        exportedAt: new Date().toISOString(),
        imagesExported,
        captionsExported,
        mapping: exportMap
    }, null, 2), 'utf-8'));

    // Add README
    const readmeContent = `
# Dataset: ${project.name}

Generated by LoRA Bento.

## Stats
- Total Images: ${imagesExported}
- Total Captions: ${captionsExported}
- Original Total: ${stats.total}
- Original Raw: ${stats.raw}
- Original Augmented: ${stats.aug}

## Configuration
- Target Size: ${project.settings.targetSize}
- Trigger Word: ${project.settings.triggerWord || 'None'}
- Caption Model: ${project.settings.captionModel || 'Manual/Imported'}

## Training Instructions
1. This dataset is structured for Kohya-ss, OneTrainer, and FluxGym.
2. Point your trainer to the \`dataset/images\` folder.
3. Use the trigger word "${project.settings.triggerWord || ''}" in your prompts if applicable.

## Sequential Renaming
Images have been renamed sequentially (000001.png, etc.) to ensure a clean training set.
See \`export_map.json\` for the mapping to original filenames.
  `.trim();

    zip.addFile('README.md', Buffer.from(readmeContent, 'utf-8'));

    console.log(`Exported project ${projectId}: ${imagesExported} images, ${captionsExported} captions.`);

    return zip.toBuffer();
}
